#ifndef AO40_SPIRAL_VIT_SCALAR_H
#define AO40_SPIRAL_VIT_SCALAR_H

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define AO40_K 7
#define AO40_RATE 2
#define AO40_POLYS { 79, -109 }
#define AO40_NUMSTATES 64
#define AO40_FRAMEBITS 2560
#define AO40_DECISIONTYPE uint32_t
#define AO40_DECISIONTYPE_BITSIZE 32
#define AO40_COMPUTETYPE uint32_t
#define AO40_COMPUTETYPE_BITSIZE 32

//ao40_decision_t is a BIT vector
typedef union {
  AO40_DECISIONTYPE t[AO40_NUMSTATES/AO40_DECISIONTYPE_BITSIZE];
  uint32_t w[AO40_NUMSTATES/32];
  unsigned short s[AO40_NUMSTATES/16];
  unsigned char c[AO40_NUMSTATES/8];
} ao40_decision_t __attribute__ ((aligned (16)));

typedef union {
  AO40_COMPUTETYPE t[AO40_NUMSTATES];
} ao40_metric_t __attribute__ ((aligned (16)));

static inline void ao40_renormalize(AO40_COMPUTETYPE* X, AO40_COMPUTETYPE threshold) {
  int i;
  if ( X[0] > threshold ) {
    AO40_COMPUTETYPE min = X[0];
    for (i = 0; i < AO40_NUMSTATES; ++i) {
      if (min > X[i])
        min = X[i];
    }
    for (i = 0; i < AO40_NUMSTATES; ++i) {
      X[i]-=min;
    }
  }
}

/* State info for instance of Viterbi decoder */
struct ao40_v {
  __attribute__ ((aligned (16))) ao40_metric_t metrics1; /* path metric buffer 1 */
  __attribute__ ((aligned (16))) ao40_metric_t metrics2; /* path metric buffer 2 */
  ao40_metric_t *old_metrics,*new_metrics; /* Pointers to path metrics, swapped on every bit */
  ao40_decision_t *decisions;   /* decisions */
};

extern AO40_COMPUTETYPE ao40_Branchtab[AO40_NUMSTATES/2*AO40_RATE] __attribute__ ((aligned (16)));

static const uint8_t ao40_Partab[256] = {
  0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 
  0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
  0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
  0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 
  0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
  0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 
  0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 
  0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
  0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
  0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 
  0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 
  0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
  0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 
  0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
  0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
  0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00
};

static inline int ao40_parity(uint32_t x){
  /* Fold down to one byte */
  x ^= (x >> 16);
  x ^= (x >> 8);
  return ao40_Partab[x];
}

int ao40_init_viterbi(void *p, int starting_state);
void *ao40_create_viterbi(int len);
int ao40_chainback_viterbi(void *p, uint8_t *data, uint32_t nbits, uint32_t endstate);
void ao40_delete_viterbi(void *p);
int ao40_update_viterbi_blk(void *p, AO40_COMPUTETYPE *syms, int nbits);

#endif /* AO40_SPIRAL_VIT_SCALAR_H */
